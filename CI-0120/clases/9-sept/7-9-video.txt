Una predicción no tomado es estática y se hace por hardware pero no se analiza realmente si se puede saltar o no, solamente se predice que no va a saltar. Esta predicción sirve en if, en ciclos no tanto. Predicción tomada no se hace de manera estática.

La siguiente solucción es la de branch retrasado: mientras el branch se está resolviendo, el procesador realiza otas instrucciones. Estas instrucciones las da el compilador, él pone después del branch las instrucciones que quiere que se ejecuten mientras se resuelve el branch. Es por esto que en esta solución el procesador y el compilador hacen un trabajo conjunto. El compilador saca las instrucciones arriba del branch, pues estas no afectan la condición del branch, además de que no pueden depender del branch y no deben tener conflictos entre ellas.
Estas instrucciones "buenas" se empiezan a ejecutar después de que comienza la instrucción del branch, de manera que cuando se sepa la condición del branch, la siguiente instrucción después de estas instrucciones "buenas" será la que corresponda de si la condición es falsa o verdadera. 
Instrucciones "buenas" son las que están entre el branch y la instrucción que se ejecuta cuando se sabe la condición, la cantidad de estas instrucciones "buenas" depende del retraso que genera un branch usualmente, si el CPI es de 3 entonces habrán 2 instrucciones. El compilador debe saber cuáles instrucciones poner ahí, algunos compiladores ponen ninguna operación "no ops". Entonces, lo que pasa es que el compilador acomoda el código en ensamblador de cierta manera que el branch está en una posición que permita poner después estas operaciones buenas.

|-----------------------|
|PIPELINE PARA FLOTANTES|
|-----------------------|

PIPELINE: camino lógico que lleva una instrucción mientras se está ejecutando.

las operaciones de punto flotante tardan mucho más que los enteros, porque los operandos vienen en cierto formato, etc. RISC-V tiene registros para enteros que van de x0-x31 y los de flotantes van de f0-f31. F0 puede ser registro destino. Los loads y stores, sean de flotantes o no, siguen el pipleine de enteros porque el cálculo que hace es de direcciones.
Para hacer una división de flotantes, después de ID el pipeline se va a D (división) en lugar de EX (como si fuera para enteros), pero esta tarda 25 veces más de lo que tarda EX, se dice que es una operación multiciclo, se hacen 25 ciclos para hacer el cálculo, al final hay un juego de registros donde se copia el IR, el ALU output de la división y se pasa a la etapa MEM. Esta etapa no está implementada como pipeline, por lo que cuando una operación entra a D1, tiene que salir de D25 para que entre otra operación.
La multiplicación se hace en 7 etapas (M), cada etapa le pasa a la siguiente su parte del cálculo, esta etapa sí se implementa como pipeline, por lo que cuando una multiplicación pasa de M1 a M2, otra multiplicación puede entrar a M1 y así sucesivamente. Entre cada etapa hay registros para que se pasen su parte. 
La suma y resta de flotantes también se implementa como pipeline y le toma 4 etapas, igual hay registros entre estas etapas.

Desde el punto de vista del compilador, la latencia de unidad funcional es el número de ciclos que hay entre una instrucción que produce los resultados y otra que los usa. El compilador para evitar conflictos de datos, debería saber la latencia de una unidad funcional. Por ejemplo, si fuera una suma de flotantes, la latencia es de 3 ciclos, por lo que el compilador debe meter 3 instrucciones en medio y poner una cuarta que utiliza el resultado de la suma. La latencia del multiplicador de flotantes es de 6 y el de división es 24. El intervalo de iniciación o de repetición, esto se refiere a cuántos ciclos se debe esperar para emitir una instrucción de una misma unidad funcional, en el caso de una operación con ALU de enteros, memoria y suma-mult-rest de flotantes el intervalo es de 1, porque se puede emitir una de estas instrucciones después de que se emitió otra del mismo tipo. En el caso de la división de flotantes, este intervalo es de 25.
Terminaciones fuera de orden: una instrucción de flotantes termina primero que una instrucción que empezó antes. Si dos instrucciones quieren entrar a una unidad funcional, por ejemplo una mul y add que terminan al mismo tiempo y quieren pasar a MEM, la que pasa primero es la instrucción más vieja. El CPI de una instrucción se calcula con los ciclos del WB de una instrucción en comparación con el WB anterior en finalizar.

Una excepción precisa es cuando en una instrucción pasa algo, pero se puede reanudar a partir de donde se dio la excepción porque todo lo demás ya se hizo, además de que la instrucción donde se va a reiniciar el programa debe ya tener sus operandos correctamente. Como en las instrucciones de flotantes hay algunas que terminan antes que otras incluso habiendo empezado después, puede que una instrucción posterior haya modificado el operando que necesita la instrucción anterior donde se va a reanudar, entonces en ese caso no es una excepción precisa. 
Trabajar en modo preciso significa que una máquina intenta que si se dan excepciones, sean precisas, usualmente desactivando el pipeline hasta que se sepa que nada va a pasar.

Conflicto WAW (write after write): sucede con flotantes, cuando una instrucción que se ejecuta primero debe escribir en un registro, pero una instrucción que se ejecuta posterior a esa también escribe en el mismo registro, y puede que esta instrucción que se empezó a ejecutar después termine antes que la que se ejecutó de primero, entonces va a hacer WB antes y eso puede afectar posteriores instrucciones del programa, porque la primera instrucción, en este caso, debía hacer la que hace el WB primero, por más que termine después. Para resolver este conflicto hay varias formas:

* Una instrucción nunca se queda esperando en MEM, para no hacer cuello de botella *

	1. Que la instrucción que debe hacer WB después, se quede en EX hasta que ya pueda hacer WB.
	2. El procesador puede utilizar registros temporales, entonces la instrucción que debe hacer WB después escribe en uno de estos registros temporales y cuando ya se pueda hacer WB al registro destino real entonces se hace.	
	
Nunca se puede guardar algo que llega por forwarding, porque es una señal y después se pierde, entonces si una instrucción está esperando dos operandos que recibiría por forwarding en distintos ciclos, debe posponer ID hasta que pueda agarrar el primero de los operandos y ahí sí ya tiene cómo almacenar uno, y se espera en lo que vaya después de ID hasta que le llegue el otro operando por forwarding. En otras palabras, una instrucción no puede recibir dos operandos por forwarding en distintos ciclos, si es en el mismo ciclo entonces sí puede.
