Con instrucciones de punto flotante y en la medida de lo posible, lo mejor es que una instrucción no se quede esperando en ID para no bloquearle el acceso a otras instrucciones, pero esto depende realmente de la implementación.
Una instrucción no puede entrar a MEM si ya hay otra ahí en ese ciclo, se queda en EX pero no lo vuelve a hacer, solo se queda ahí y la instrucción más vieja tiene prioridad para acceder a MEM. 
Cuando se hace un forwarding, no se puede hacer que la instrucción se quede esperando por el otro operando porque lo que se envía por forwarding no hay dónde guardarlo, entonces si una instrucción ocupa dos operandos que eventualmente llegarían por forwarding, tiene que aplazarse ID hasta que uno de los operandos haya pasado por WB de otra instrucción entonces ya ahora sí la instrucción que lo necesita puede hacer ID y tenerlo almacenado en espera del segundo operando. Puede recibir los dos operandos por forwarding si se reciben en el mismo ciclo.

PIPELINE DE MIPS R4000

es superpipelining porque tiene muchas etapas, en este pipeline se dividen las dos etapas más lentas que son IF y MEM por los accesos a caché. El IF se divide en tres etapas, en la primera solamente se pide la instrucción, en la segunda la caché de instrucciones le da la instrucción y la tercera se junta con la ID, en esta se detecta si hubo hit o no en la caché. En MEM también se divide en 3 etapas, donde las primeras dos solo son solo para los loads, pues en la primera se pide el dato a la caché de datos y en la segunda se lo dan (aquí también se puede hacer forwarding), y en la tercera se determina si también hubo hit o no de la caché. Con esto se gana que la longitud de ciclo de reloj sea menor. 
El store no puede hacer pipeline de MEM, tiene que esperar a que otra instrucción suelte la tercera etapa de MEM y ninguna instrucción puede entrar a la primera etapa de MEM hasta que el store termine la tercera etapa.
