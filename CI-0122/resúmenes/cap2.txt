2.1 SERVICIOS DE UN SISTEMA OPERATIVO

 1. Interfaz de usuario: está la GUI y la CLI (command-line interface).
 2. Ejecución de programas: cargarlos a mem. y correrlos, terminar su ejecución.
 3. Operaciones de I/O: el usuario no suele manejarlas directamente.
 4. Manipulación de archivos.
 5. Comunicación entre procesos: mediante memoria compartida o paso de mensajes.
 6. Detección de errores: tanto en CPU, hardware, dispositivos de I/O o en programas del usuario.
 
Algunas otras son para uso eficiente del sistema operativo:

 7. Asignador de recursos: para asignar recursos a los procesos que corren al mismo tiempo.
 8. Bitácoras (logging): mantener un registro de los recursos utilizados.
 9. Seguridad: acceso controlado a los recursos del sistema. Autenticación de usuarios, etc.
 
 
2.2 INTERFAZ DE USUARIO-SISTEMA OPERATIVO

 1. Intérprete de comandos: su función principal es de obtener y ejecutar los comandos que indique del usuario. Para implementar estos comandos existen dos formas: una es que el intérprete tenga el código para ejecutar los comandos y el otro es que el código de los comandos esté en archivos y que el comando sea para identificar cuál archivo ejecutar, por lo que es más fácil si alguien quisiera crear su propio comando creando su archivo que indique la lógica y el código de lo que se quiera hacer.
 
 2. GUI: en lugar de indicar comandos, se usa mouse-teclado-etc para indicar lo que se quiere hacer
 
 3. Interfaz táctil.
 
 
2.3 SYSTEM CALLS
 
 1. Interfaz de programación de aplicaciones: usualmente se diseñan programas de acuerdo con un API, que especifica una serie de instrucciones disponibles para el programador, algunos son: Windows API, POSIX API y Java API. Las funciones que componen estas API's hacen llamado y uso de los syscalls. Programar con base en un API y no directamente con syscalls permiten la portabilidad de un programa. Otro aspecto importante al manejar syscalls es el RTE (run-time environment) que provee una interfaz de syscalls que sirve como enlace a los syscalls disponibles en el S.O. Usualmente cada syscall se asocia a un id y el S.O maneja una tabla con esos id. 
 Se utilizan tres métodos para pasar parámetros a los syscalls:
 
  	I. Pasar parámetros a registros.
  	II. Los parámetros se almacenan en bloques o tablas en memoria y la dirección de estos se envía como parámetro a los registros (si hay más parm que registros).
  	III. También se puede usar una pila donde el S.O hace push y pop según necesite.
  	
 2. Tipos de syscalls:
 
 	I. Control de procesos: un programa debe ser capaz de detener su ejecución de manera normal o abrupta. Si es de manera abrupta, se escribe un registro en un log file. También un proceso puede que quiera cargar o ejecutar otro programa. O un proceso padre esperar a otros procesos creados. Al compartir información entre procesos utilizar un lock para dar acceso controlado a esa información. Ejs: create process, terminate process, load, signal event, get process attributes.
 	
 	II. Manejo de archivos: para crear y eliminar archivos, abrirlos o cerrarlos, además de escribir y leer.
 	
 	III. Manejo de dispositivos: para cuando un proceso necesite de recursos como la mem. principal, drivers, etc. Si estos recursos están disponibles, se les dan al proceso, si no tiene que esperar.
 	
 	IV. Mantenimiento de información: para transferir información entre un programa de usuario y el S.O. Útiles para el debugger. 
 	
 	V. Comunicación: útiles para comunicación entre procesos, existen las formas de paso de mensajes (buzones) y memoria compartida.
 	
 	VI. Protección: mecanismo para controlar acceso a los recursos provistos por el sistema. Son para manipular permisos de los recursos y para verificar si un usuario tiene acceso o no a ciertos recursos.
 	
 	
2.4 SERVICIOS DEL SISTEMA

 Proveen un ambiente para el desarrollo y ejecución de programas.
 
 1. Manejo de archivos.
 2. Información: solicita datos como fecha, espacio disponible, etc.
 3. Edición de archivos.
 4. Soport para programación con lenguajes.
 5. Cargar y ejecutar programas.
 6. Comunicación: entre procesos, usuarios, etc.


2.5 LINKERS & LOADERS

 Un programa está en el disco como un binario (.out / .exe), y para correrlo, debe ser traído a memoria y colocarlo en el contexto de un proceso. 
 El código fuente es compilado como object files, el linker combina estos object files en un único archivo binario, en esta fase también se incluyen librerías, etc. 
 El loader se usa para cargar el archivo binario en memoria donde es elegible para correr en un núcleo del CPU. 
 La reubicación (relocation) asigna direcciones finales al programa para que funcione adecuadamente. 
 Muchos S.O permiten a un programa linkear librerías de manera dinámica mientras se carga el programa (loader), esto evita linkear librarías que al final no se van a usar, pues se cargan en el momento en que el código lo necesite en tiempo de ejecución. 
 Los object files y ejecutables tienen formatos que incluyen el código máquina y una tabla de símbolos con la información de las funciones y variables del programa. En UNIX el estándar es ELF.
 	
 	
2.6 POR QUÉ LAS APLICACIONES SON ESPECÍFICAS PARA UN S.O

 Cada S.O posee un único set de syscalls. Sin embargo, una aplicación puede ser ejecutada en distintos S.O en tres maneras distintas:
 
 	1. La aplicación puede haber estado escrita en un lenguaje interpretado (como Python o Ruby) y el intérprete está disponible en múltiples S.O's.
 	2. La aplicación puede ser escrita en un lenguaje que incluye una máquina virtual (Java), que ha sido desarrolada para muchos S.O's. 
 	3. El desarrollador puede usar un lenguaje estandarizado o una API. 
 	
 Dificultades de bajo nivel en los S.O que no permiten que muchas aplicaciones corran en distintos S.O:
 	
 	1. Cada S.O tiene un formato binario para aplicaciones que indica la disposición del header, instrucciones y variables donde están en direcciones específicas.
 	2. Los CPU's tienen sets de instrucciones variados.
 	3. Los syscalls varían dependiendo del S.O.
 	
 	
2.7 DISEÑO E IMPLEMENTACIÓN DEL S.O

 	1. Objetivos del diseño: se debe definir para qué va a ser el S.O, en alto nivel el diseño se ve afectado por el hardware. Los requerimentos pueden ser objetivos del usuario o del sistema. Debe ser conveniente y fácil de usar, seguros y rápidos. Debe ser fácil de implementar y de mantener. 
 	
 	2. Mecanismos y políticas: el mecanismo determina cómo hacer algo y las políticas qué se puede hacer. Las políticas pueden cambiar con el paso del tiempo, es necesario que ambos no estén tan ligados para que este cambio constante en las políticas no conlleve un cambio en el mecanismo.
 	
 	3. Implementación: hoy día muchos S.O están escritos en C, C++ y pequeñas porciones en ensamblador. Las ventajas de escribirlo en lenguajes de alto nivel es lo compacto, rápido de hacer, de depurar y es más portable hacia otro hardware. 
 	
 	
2.8 ESTRUCTURA DE UN S.O
 
 Para que funcione bien y sea fácil de modificar, los S.O se componen de modulos, que define una parte del sistema.
 
 	I. Estructura monolítica (una pieza): cargar todas las funcionalidades en el kernel. 
 	
 	II. Solución por capas: el sistema se divide en pequeños componentes con funcionalidades específicas. La ventaja es que cambios en un componente solo afecta a ese componente y no a los demás. En la solución por capas se busca la simplicidad de construir y depurar (capa0=hardware, capaN=interfaz de usuario). Una capa se implementa con operaciones provistas por capas más bajas, no le importa cómo se implementan, sino qué hacen. En general tienen un rendimiento pobre.
 	
 	III. Microkernels: este método estructura el S.O al remover componentes no esenciales del kernel e implementándolos como programas de user-level que residen en distintas direcciones de memoria, resultado: un kernel más pequeño. La función principal es de proveer comunicación entre un programa cliente y otros servicios corriendo igualmente en el user space. Permite portabilidad con distinto hardware, mayor seguridad y fiabilidad.
 	
 	IV. Módulos: el kernel tiene un set de copmonentes y puede linkear otros servicios con módulos en tiempo de ejecución o de arranque.
 	
 	V. Sistemas híbridos: sistemas que combinan diferentes estructuras para conseguir rendimiento, seguridad, etc.
 	
 	 - macOS & iOS: tiene una capa de experiencia de usuario que define la interfaz de software con el que los usuarios interactúan. Tiene una capa con frameworks de aplicaciones y otra de frameworks del núcleo (para gráficos y multimedia). Por último tiene un ambiente de kernel.
 	 - Android.
 	 
 	 
2.9 CONSTRUIR Y ARRANCAR UN S.O

 	1. Construir un S.O desde cero: 
 	 - Escribir el código fuente del S.O.
 	 - Configurar el S.O para el sistema en que va a correr.
 	 - Compilar el S.O.
 	 - Instalar el S.O.
 	 - Arrancar la PC con el nuevo S.O.
 	 
 	2. System Boot (cargar el kernel): El proceso es el siguiente:
 	 - Un pequeño código (boot loader/bootstrap) localiza el kernel.
 	 - El kernel se carga a memoria y se ejecuta.
 	 - El kernel inicializa el hardware.
 	 - Se monta el root file system.
 	 
