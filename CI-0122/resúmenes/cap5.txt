VIDEO: 9 noviembre parte 2

---------------------- 5.1 CONCEPTOS BÁSICOS ----------------------

El objetivo de multiprogramación es maximizar el uso de la CPU.

5.1.1 CPI-I/O BURST CYCLE

Un proceso cambia de estado, comenzando con una ráfaga (burst) de CPU y luego de I/0, y así constantemente.

5.1.2 CPU SCHEDULER

Selecciona un proceso de memoria que está listo para ejecutar y le asigna el CPU a ese proceso.

5.1.3 ASIGNACIÓN REVOCATIVA O NO REVOCATIVA

El CPU toma decisiones en las siguienstes circunstancias:

	i. un proceso cambia de estado: ejecutando a esperando.
	ii. proceso cambia de ejecutando a listo.
	iii. proceso cambia de esperando a listo.
	iv. cuando un proceso termina.
	
La i y iv son no revocables (no se pueden atrasar), las otras dos sí son revocables.

5.1.4 DISPATCHER

Módulo que le asigna el control del CPU al proceso seleccionado por el CPU scheduler, su función involucra lo siguiente:

	i. switch context de un proceso a otro.
	ii. switch a user mode
	iii. saltar a la dirección apropiada para resumir el programa.
	
El tiempo que tarda en hacer esto se llama dispatch latency


---------------------- 5.2 SCHEDULING CRITERIA ----------------------


Criterios para asignarle el CPU a un proceso:

	i. uso del cpu. (CPU utilization)
	ii. rendimiento (throughput): cantidad de procesos completos por unidad de tiempo.
	iii. tiempo de respuesta (turnaround time): tiempo desde que se creó el proceso hasta que terminó.
	iv. tiempo de espera: tiempo de espera en cola.
	v. tiempo de respuesta: tiempo entre una solicitud y su respuesta.
	
	
---------------------- 5.3 ALGORITMOS DE ASIGNACIÓN ----------------------


5.3.1 FIRST-COME, FIRST-SERVED SCHEDULING (FCFS)

El proceso que solicita la CPU de primero, se le asigna de primero. Se produce el efecto convoy: procesos cortos deben esperar detrás de procesos muy largos.

5.3.2 SHORTEST-JOB-FIRST SCHEDULING (SJF)

Cuando la CPU está disponible, se le asigna al proceso con el CPU burst más pequeño de la cola, si hay dos iguales, se usa FCFS. Es óptimo si se conoce el tiempo de uso del CPU de los procesos, lo cual no se puede hacer, por lo que se hace una estimación.

5.3.3 ROUND-ROBIN SCHEDULING 

Se añade una unidad de tiempo llamada quantim, la cola de espera es una cola circular asignándole a cada uno un tiempo igual al quantum, por lo que se van asignando en orden FIFO. El quantum debe ser mayor que lo que tarda el context switch para que tenga sentido.

5.3.4 PRIORITY SCHEDULING

Se asocia una prioridad a cada proceso. Con procesos de igual prioridad se usa FCFS. Las prioridades se definen internamente o externamente. Se pueden dar problemas de bloqueos indefinidos (starvation), como un proceso con prioridad baja puede quedarse esperando indefinidamente. Una solución es aging, subirle la prioridad al proceso conforme pasa al tiempo.
Se puede mezclar esta estrategia con el Round-Robin, procesos con misma prioridad se usa RR.

5.3.5 MULTILEVEL QUEUE SCHEDULING

Tener distintas colas, una para cada prioridad que haya y cada cola se le aplica su propia estrategia.

5.3.6 MULTILEVEL FEEDBACK QUEUE SCHEDULING

Permite a un proceso moverse entre cola.
